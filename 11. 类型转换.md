## 11. 类型转换

除了支持跨语言函数调用，pybind11这类绑定工具必须处理的一个基本问题就是，提供在C++中访问原生Python类型的方式，反之亦然。有三种完全不同的方法做到这点，每种方法适用性取决于你使用的环境。

1. 任意侧使用原生的C++类型。这种情况下，必须使用pybind11生成类型的绑定，Python才能使用它。
2. 任意侧使用原生的Python类型。同样需要包装后，C++函数才能够使用它。
3. C++侧使用原生C++类型，Python侧使用原生Python类型。pybind11称其为类型转换。
   某种意义下，在任意侧使用原生类型，类型转换是最自然的选项。该方法主要的缺点是，每次Python和C++之间转换时都需要拷贝一份数据，因为C++和Python的对相同类型的内存布局不一样。
   pybind11可以自动完成多种类型的转换。后面会提供所有内置转换的表格。

下面的小节将更详细地讨论这些选项之间的区别。

### 11.1 概述

**1. Native type in C++, wrapper in Python**

在“面对对象编程”一章中，我们详细介绍了通过`py::class_`公开自定义C++类型的方法。这里，底层的数据结构仍然是原始的C++类，而`py::class_`包装则提供了Python侧的接口。当一个对象从C++侧发送到Python侧时，pybind11仅仅在原始的C++对象上增加了一层包装而已。从Python侧获取它也仅仅是撕掉了包装而已。

**2. Wrapper in C++, native type in Python**

这与上面是完全相反的情况。现在我们有一个原生的Python类型，如tuple或list。在C++侧获取这个数据的一种方法是使用`py::object`族包装器。这将在后续章节详细解释。这里举个简单的例子：

```c++
void print_list(py::list my_list) {
    for (auto item : my_list)
        std::cout << item << " ";
}
```

```python
>>> print_list([1, 2, 3])
1 2 3
```

Python的list仅仅是包裹在了C++ `py::list`类里，并没有仅仅任何转换。它的核心任然是一个Python对象。拷贝一个`py::list`会像Python中一样增加引用计数。将对象返回到Python侧，将去掉这层封装。

**3. Converting between native C++ and Python types**

前面两种情况，我们在一种语言中使用原生类型，而在另一种语言中使用它的包装类型。现在，我们在两侧都使用原生类型，并对他们进行类型转换。

```c++
void print_vector(const std::vector<int> &v) {
    for (auto item : v)
        std::cout << item << "\n";
}
```

```python
>>> print_vector([1, 2, 3])
1 2 3
```

这个例子中，pybind11将创建一个`std::vector<int>`实例，并从Python list中拷贝每个元素。然后将该实例传递给`print_vector`。同样的事情发生在另一个方向：新建了一个list，并从C++的vector中获取元素值。

如下表所示，多数转换是开箱即用的。他们相当方便，但请记住一点，这些转换是基于数据拷贝的。这对小型的不变的类型相当友好，对于大型数据结构则相当昂贵。这可以通过自定义包装类型重载自动转换来规避（如上面提到的方法1）。This requires some manual effort and more details are available in the [Making opaque types](https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque) section.

**内置转换的列表**

下面基础数据类型是开箱即用的（有些可能需要include额外的头文件）。

| Data type                                       | Description                                                  | Header file             |
| ----------------------------------------------- | ------------------------------------------------------------ | ----------------------- |
| `int8_t`, `uint8_t`                             | 8-bit integers                                               | `pybind11/pybind11.h`   |
| `int16_t`, `uint16_t`                           | 16-bit integers                                              | `pybind11/pybind11.h`   |
| `int32_t`, `uint32_t`                           | 32-bit integers                                              | `pybind11/pybind11.h`   |
| `int64_t`, `uint64_t`                           | 64-bit integers                                              | `pybind11/pybind11.h`   |
| `ssize_t`, `size_t`                             | Platform-dependent size                                      | `pybind11/pybind11.h`   |
| `float`, `double`                               | Floating point types                                         | `pybind11/pybind11.h`   |
| `bool`                                          | Two-state Boolean type                                       | `pybind11/pybind11.h`   |
| `char`                                          | Character literal                                            | `pybind11/pybind11.h`   |
| `char16_t`                                      | UTF-16 character literal                                     | `pybind11/pybind11.h`   |
| `char32_t`                                      | UTF-32 character literal                                     | `pybind11/pybind11.h`   |
| `wchar_t`                                       | Wide character literal                                       | `pybind11/pybind11.h`   |
| `const char *`                                  | UTF-8 string literal                                         | `pybind11/pybind11.h`   |
| `const char16_t *`                              | UTF-16 string literal                                        | `pybind11/pybind11.h`   |
| `const char32_t *`                              | UTF-32 string literal                                        | `pybind11/pybind11.h`   |
| `const wchar_t *`                               | Wide string literal                                          | `pybind11/pybind11.h`   |
| `std::string`                                   | STL dynamic UTF-8 string                                     | `pybind11/pybind11.h`   |
| `std::u16string`                                | STL dynamic UTF-16 string                                    | `pybind11/pybind11.h`   |
| `std::u32string`                                | STL dynamic UTF-32 string                                    | `pybind11/pybind11.h`   |
| `std::wstring`                                  | STL dynamic wide string                                      | `pybind11/pybind11.h`   |
| `std::string_view`, `std::u16string_view`, etc. | STL C++17 string views                                       | `pybind11/pybind11.h`   |
| `std::pair<T1, T2>`                             | Pair of two custom types                                     | `pybind11/pybind11.h`   |
| `std::tuple<...>`                               | Arbitrary tuple of types                                     | `pybind11/pybind11.h`   |
| `std::reference_wrapper<...>`                   | Reference type wrapper                                       | `pybind11/pybind11.h`   |
| `std::complex<T>`                               | Complex numbers                                              | `pybind11/complex.h`    |
| `std::array<T, Size>`                           | STL static array                                             | `pybind11/stl.h`        |
| `std::vector<T>`                                | STL dynamic array                                            | `pybind11/stl.h`        |
| `std::deque<T>`                                 | STL double-ended queue                                       | `pybind11/stl.h`        |
| `std::valarray<T>`                              | STL value array                                              | `pybind11/stl.h`        |
| `std::list<T>`                                  | STL linked list                                              | `pybind11/stl.h`        |
| `std::map<T1, T2>`                              | STL ordered map                                              | `pybind11/stl.h`        |
| `std::unordered_map<T1, T2>`                    | STL unordered map                                            | `pybind11/stl.h`        |
| `std::set<T>`                                   | STL ordered set                                              | `pybind11/stl.h`        |
| `std::unordered_set<T>`                         | STL unordered set                                            | `pybind11/stl.h`        |
| `std::optional<T>`                              | STL optional type (C++17)                                    | `pybind11/stl.h`        |
| `std::experimental::optional<T>`                | STL optional type (exp.)                                     | `pybind11/stl.h`        |
| `std::variant<...>`                             | Type-safe union (C++17)                                      | `pybind11/stl.h`        |
| `std::filesystem::path<T>`                      | STL path (C++17) [1](https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html#id2) | `pybind11/stl.h`        |
| `std::function<...>`                            | STL polymorphic function                                     | `pybind11/functional.h` |
| `std::chrono::duration<...>`                    | STL time duration                                            | `pybind11/chrono.h`     |
| `std::chrono::time_point<...>`                  | STL date/time                                                | `pybind11/chrono.h`     |
| `Eigen::Matrix<...>`                            | Eigen: dense matrix                                          | `pybind11/eigen.h`      |
| `Eigen::Map<...>`                               | Eigen: mapped memory                                         | `pybind11/eigen.h`      |
| `Eigen::SparseMatrix<...>`                      | Eigen: sparse matrix                                         | `pybind11/eigen.h`      |

### 11.2 Strings, bytes and Unicode conversions

> Note: 本节讨论的string处理基于Python3 strings。对于python2.7，使用`unicode`替换`str`，`str`替换`bytes`。Python2.7用于最好使用`from __future__ import unicode_literals`避免无意间使用`str`代替`unicode`。

#### 11.2.1 传递Python strings到C++

当向一个接收`std::string`或`char *`参数的函数传递Python的`str`时，pybind11会将Python字符串编码为UTF-8。所有的Python `str`都能够用UTF-8编码，所以这个操作不会失败。

C++语言是encoding agnostic。程序员负责处理编码，最简单的做法就是每处都使用UTF-8。

```c++
m.def("utf8_test",
    [](const std::string &s) {
        cout << "utf-8 is icing on the cake.\n";
        cout << s;
    }
);
m.def("utf8_charptr",
    [](const char *s) {
        cout << "My favorite food is\n";
        cout << s;
    }
);
```

```python
>>> utf8_test("🎂")
utf-8 is icing on the cake.
🎂

>>> utf8_charptr("🍕")
My favorite food is
🍕
```

> Note: 有些终端模拟器不支持UTF-8或emoji字体，上面的例子可能无法显示。

无论C++函数的参数是传值或引用，是否是const，结果都是一样的。

**向C++传递bytes对象**

向接收`std::string`或`char *`类型参数的C++函数传递Python bytes对象无需转换。在Python3上，如果想要函数只接收bytes，不接收str，可以声明参数类型为`py::bytes`。

#### 11.2.2 向Python返回C++ 字符串

当C++函数返回`std::string`或`char*`参数给Python调用者时，pybind11会将字符串以UTF-8格式解码给原生Python str，类似于Python中的`bytes.decode('utf-8')`。如果隐式转换失败，pybind11将会抛出异常`UnicodeDecodeError`。

```c++
m.def("std_string_return",
    []() {
        return std::string("This string needs to be UTF-8 encoded");
    }
);
```

```python
>>> isinstance(example.std_string_return(), str)
True
```

因为UTF-8包含纯ASCII，返回一个纯ASCII字符串到Python没有任何问题。否则就需要确保编码是有效的UTF-8。

> Warning: 隐式转换假定`char *`字符串以null为结束符。若不是，将导致缓冲区溢出。

**显式转换**

如果C++代码构造了一个非UTF-8的string字符串，可以执行显式转换并返回`py::str`对象。显式转换与隐式转换的开销相同。

```c++
// This uses the Python C API to convert Latin-1 to Unicode
m.def("str_output",
    []() {
        std::string s = "Send your r\xe9sum\xe9 to Alice in HR"; // Latin-1
        py::str py_s = PyUnicode_DecodeLatin1(s.data(), s.length());
        return py_s;
    }
);
```

```python
>>> str_output()
'Send your résumé to Alice in HR'
```

 [Python C API](https://docs.python.org/3/c-api/unicode.html#built-in-codecs)提供了一些内置的编解码方法可以使用。也可以使用第三方库如libiconv 来转换UTF-8。

**不使用类型转换来返回C++字符串**

如果C++ `std::string`中的数据不表示文本，则应该以`bytes`的形式传递给Python，这时我们可以返回一个`py::btyes`对象。

```c++
m.def("return_bytes",
    []() {
        std::string s("\xba\xd0\xba\xd0");  // Not valid UTF-8
        return py::bytes(s);  // Return the data without transcoding
    }
);
```

```python
>>> example.return_bytes()
b'\xba\xd0\xba\xd0'
```

注意：pybind11可以将bytes无需编码地转换为`std::string`，但不能不经编码地隐式转换`std::string`到bytes。

```c++
m.def("asymmetry",
    [](std::string s) {  // Accepts str or bytes from Python
        return s;  // Looks harmless, but implicitly converts to str
    }
);
```

```python
>>> isinstance(example.asymmetry(b"have some bytes"), str)
True

>>> example.asymmetry(b"\xba\xd0\xba\xd0")  # invalid utf-8 as bytes
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xba in position 0: invalid start byte
```

#### 11.2.3 宽字符串

向入参为`std::wstring`、`wchar_t*`、`std::u16string`或`std::u32string`的C++函数传递Python str对象，str将被编码为UTF-16或UTF-32（具体哪种取决于C++编译器的支持）。当C++函数返回这些类型的字符串到Python str时，需要保证字符串是合法的UTF-16或UTF-32。

```c++
#define UNICODE
#include <windows.h>

m.def("set_window_text",
    [](HWND hwnd, std::wstring s) {
        // Call SetWindowText with null-terminated UTF-16 string
        ::SetWindowText(hwnd, s.c_str());
    }
);
m.def("get_window_text",
    [](HWND hwnd) {
        const int buffer_size = ::GetWindowTextLength(hwnd) + 1;
        auto buffer = std::make_unique< wchar_t[] >(buffer_size);

        ::GetWindowText(hwnd, buffer.data(), buffer_size);

        std::wstring text(buffer.get());

        // wstring will be converted to Python str
        return text;
    }
);
```

> 警告：带`--enable-unicode=ucs2`选项编译的Python 2.7和3.3版本可能不支持上述的宽字符串。

多字节编码地字符串，如Shift-JIS，必须转换为UTF-8/16/32后，再返回给Python。

#### 11.2.4 字符类型

向一个入参为字符类型（char, wchar_t）的C++函数，传递Python str，C++函数将接收str的首字符。如果字符串超过一个Unicode字符长度，将忽略尾部字节。

当C++返回一个字符变量时，它将被转化为单字符的str变量。

```c++
m.def("pass_char", [](char c) { return c; });
m.def("pass_wchar", [](wchar_t w) { return w; });
```

```python
example.pass_char("A")
'A'
```

虽然C++可以将整数转换为字符类型（`char c = 0x65`），pybind11并不会隐式转换Python整数到字符类型。可以使用`chr()`Python函数来将整数转换为字符。

```python
>>> example.pass_char(0x65)
TypeError

>>> example.pass_char(chr(0x65))
'A'
```

如果需要使用8-bit整数，可使用`int8_t`或`uint8_t`作为参数类型。

#### 11.2.5 Grapheme clusters

A single grapheme may be represented by two or more Unicode characters. For example ‘é’ is usually represented as U+00E9 but can also be expressed as the combining character sequence U+0065 U+0301 (that is, the letter ‘e’ followed by a combining acute accent). The combining character will be lost if the two-character sequence is passed as an argument, even though it renders as a single grapheme.

```
>>> example.pass_wchar("é")
'é'

>>> combining_e_acute = "e" + "\u0301"

>>> combining_e_acute
'é'

>>> combining_e_acute == "é"
False

>>> example.pass_wchar(combining_e_acute)
'e'
```

Normalizing combining characters before passing the character literal to C++ may resolve *some* of these issues:

```
>>> example.pass_wchar(unicodedata.normalize("NFC", combining_e_acute))
'é'
```

In some languages (Thai for example), there are [graphemes that cannot be expressed as a single Unicode code point](http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries), so there is no way to capture them in a C++ character type.

#### 11.2.6 c++17 string_view

C++17 string views are automatically supported when compiling in C++17 mode. They follow the same rules for encoding and decoding as the corresponding STL string type (for example, a `std::u16string_view` argument will be passed UTF-16-encoded data, and a returned `std::string_view` will be decoded as UTF-8).

### 11.3 STL容器

#### 11.3.1 自动转换

包含头文件`pybind11/stl.h`后，自动支持 `std::vector<>`/`std::deque<>`/`std::list<>`/`std::array<>`/`std::valarray<>`, `std::set<>`/`std::unordered_set<>`, 和`std::map<>`/`std::unordered_map<>` 到Python `list`, `set` 和 `dict` 的类型转换。 `std::pair<>` 和`std::tuple<>` 类型转换在`pybind11/pybind11.h`中已经支持。

隐式转换的主要缺点就是Python和C++之间的容器类型转换都需要拷贝数据，这对程序语义和性能有一定的影响。后续章节将介绍如何避免该问题。

> Note: 这些类型任意嵌套都是可以的。

#### 11.3.2 C++17库的容器

`pybind11/stl.h`支持C++17的 `std::optional<>` 和`std::variant<>`，C++14的`std::experimental::optional<>`。

C++11中也存在这些容器的其他版本，如Boost中。pybind11提供了一个简单的方法`type_caster`来处理这些类型：

```c++
// `boost::optional` as an example -- can be any `std::optional`-like container
namespace pybind11 { namespace detail {
    template <typename T>
    struct type_caster<boost::optional<T>> : optional_caster<boost::optional<T>> {};
}}
```

上述内容应放到头文件中，并在需要的地方包含它们。Similarly, a specialization can be provided for custom variant types:

```c++
// `boost::variant` as an example -- can be any `std::variant`-like container
namespace pybind11 { namespace detail {
    template <typename... Ts>
    struct type_caster<boost::variant<Ts...>> : variant_caster<boost::variant<Ts...>> {};

    // Specifies the function used to visit the variant -- `apply_visitor` instead of `visit`
    template <>
    struct visit_helper<boost::variant> {
        template <typename... Args>
        static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {
            return boost::apply_visitor(args...);
        }
    };
}} // namespace pybind11::detail
```

The `visit_helper` specialization is not required if your `name::variant` provides a `name::visit()` function. For any other function name, the specialization must be included to tell pybind11 how to visit the variant.

> Warning: When converting a `variant` type, pybind11 follows the same rules as when determining which function overload to call ([Overload resolution order](https://pybind11.readthedocs.io/en/stable/advanced/functions.html#overload-resolution)), and so the same caveats hold. In particular, the order in which the `variant`’s alternatives are listed is important, since pybind11 will try conversions in this order. This means that, for example, when converting `variant<int, bool>`, the `bool` variant will never be selected, as any Python `bool` is already an `int` and is convertible to a C++ `int`. Changing the order of alternatives (and using `variant<bool, int>`, in this example) provides a solution.

#### 11.3.3 制作opaque类型









